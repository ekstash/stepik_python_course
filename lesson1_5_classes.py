class MyClass:
    a = 10

    def func(self):  # принимает в качестве объекта сам этот класс (см. ниже)
        print('Hello')


# тип MyClass - 'type'.

print(MyClass.a)
MyClass.func(MyClass)

x = MyClass()  # при этом сначала создает общий класс, затем уже экземпляр.
x.func()  # однако с созданием объекта класса он уже передан в func()


# при желании мы можем создать пустой класс:
class Empty:
    pass


class Counter:
    def __init__(self, start=0):  # мы можем сами прописать конструктор внутри класса
        self.count = start

    def reset(self):  # это - метод. он, также как и конструктор, при запуске x.reset() примет в качестве значения
        # сам экземпляр x.
        self.count = 0  # однако если в конструкторе не определить self.count, питон будет работать с count-oм
        # класса вместо count-a экземпляра.


# мы можем что-то менять в классах и их атрибутах. не только в экземплярах, как на примере, но и в самих классах.
x = Counter(10)  # первым значением автоматтически передался x, передаем сразу второе
print(x.count)  # = 10
x.count += 1
x.reset()
print(x.count)


class Song:
    tags = []

    def add_tags(self, *args):
        self.tags.extend(args)  # все будет писаться в общий список, поскольку свой не инициализирован - в силу связи
        # списков через ссылки. ОДНАКО. С неизменяемыми переменными, например, численными, это не так.
